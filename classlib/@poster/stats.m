function Stat = stats(This,Theta,varargin)
% stats  Evaluate selected statistics of ARWM chain.
%
% Syntax
% =======
%
%     S = stats(Pos,Theta,...)
%     S = stats(Pos,Theta,LogPost,...)
%     S = stats(Pos,FName,...)
%
% Input arguments
% ================
%
% * `Pos` [ poster ] - Posterior simulator object that has generated the
% `Theta` chain.
%
% * `Theta` [ numeric ] - MCMC chain generated by the
% [`poster/arwm`](poster/arwm) function.
%
% * `LogPost` [ numeric ] - Vector of log posterior densities generated by
% the `arwm` function; `LogPost` is not necessary if you do not request
% `'mdd'`, the marginal data density.
%
% * `FName` [ char ] - File name under which the simulated chain was saved
% when `arwm` was run with options `saveEvery=`' and `'saveAs='`.
%
% Output arguments
% =================
%
% * `S` [ struct ] - Struct with the statistics requested by the user.
%
% Options
% ========
%
% * `'estTime='` [ `true` | *`false`* ] - Display and update the estimated time
% to go in the command window.
%
% * `'mddGrid='` [ numeric | *`0.1:0.1:0.9`* ] - Points between 0 and 1
% over which the marginal data density estimates will be averaged, see
% Geweke (1999).
%
% * `'progress='` [ `true` | *`false`* ] - Display progress bar in the
% command window.
%
% Options to include/exclude output statistics
% =============================================
%
% * `'bounds='` [ `true` | *`false`* ] - Include in `S` the lower and upper
% parameter bounds set up by the user.
%
% * `'chain='` [ *`true`* | `false` ] - Include in `S` the entire simulated
% chains of parameter values.
%
% * `'cov='` [ `true` | *`false`* ] - Include in `S` the sample covariance
% matrix.
%
% * '`hist=`' [ numeric | *empty* ] - Include in `S` histogram bins and counts
% with the specified number of bins.
%
% * `'hpdi='` [ *`false`* | numeric ] - Include in `S` the highest
% probability density intervals with the specified coverage.
%
% * `'ksdensity='` [ `true` | *`false`* | numeric ] - Include in `S` the x-
% and y-axis points for kernel-smoothed posterior density; use a numeric
% value to control the number of points over which the density is computed.
%
% * `'mdd='` [ *`true`* | `false` ] - Include in `S` minus the log marginal
% data density.
%
% * `'mean='` [ *`true`* | `false` ] - Include in `S` the sample averages.
%
% * `'median='` [ `true` | *`false`* ] - Include in `S` the sample medians.
%
% * `'mode='` [ `true` | *`false`* ] - Include in `S` the sample modes
% based on histograms.
%
% * `'prctile='` [ numeric | *empty* ] - Include in `S` the specified
% percentiles.
%
% * `'std='` [ *`true`* | `false` ] - Include in `S` the sample std
% deviations.
%
% Description
% ============
%
% Example
% ========
%

% -IRIS Toolbox.
% -Copyright (c) 2007-2013 IRIS Solutions Team.

if ~isempty(varargin) && isnumeric(varargin{1})
    LogPost = varargin{1};
    varargin(1) = [];
else
    LogPost = [];
end

opt = passvalopt('poster.stats',varargin{:});

doOutpOpt();

% Simulated chain has been saved in a collection of mat files.
isFile = ischar(Theta);

if opt.mdd && isempty(LogPost) && ~isFile
    utils.error('poster', ...
        ['Vector of log posterior densities must be entered ', ...
        'if ``mdd`` is requested.']);
end

%--------------------------------------------------------------------------

Stat = struct();

if isFile
    [p,t] = fileparts(Theta);
    inputfile = fullfile(p,t);
    master = struct([]);
    mat = {};
    nPar = NaN;
    N = NaN;
    doChkPosterFiles();
else
    [nPar,N] = size(Theta);
end

if opt.mean || opt.cov || opt.std || opt.mdd
    thetaMean = nan(nPar,1);
    doMean();
end

if opt.progress
    progress = progressbar('IRIS poster.arwm progress');
elseif opt.esttime
    eta = esttime('IRIS poster.arwm is running');
end

for i = 1 : nPar
    name = This.paramList{i};
    
    if isFile
        theta = nan(1,master.Draw);
        doGetTheta(i);
    else
        theta = Theta(i,:);
    end
    
    if opt.mode || opt.hist
        [histCount,histBins] = hist(theta,opt.histbins);
    end
    
    if opt.chain
        Stat.chain.(name) = theta;
    end
    if opt.mean
        Stat.mean.(name) = thetaMean(i);
    end
    if opt.median
        Stat.median.(name) = median(theta);
    end
    if opt.mode
        pos = find(histCount == max(histCount));
        % If more than one mode is found, pick the middle one.
        npos = length(pos);
        if npos > 1
            pos = pos(ceil((npos+1)/2));
        end
        Stat.mode.(name) = histBins(pos);
    end
    if opt.std
        Stat.std.(name) = ...
            sqrt(sum((theta - thetaMean(i)).^2) / (N-1));
    end
    if isnumeric(opt.hpdi) && ~isempty(opt.hpdi)
        [low,high] = tseries.myhpdi(theta,opt.hpdicover,2);
        Stat.hpdi.(name) = [low,high];
    end
    if isnumeric(opt.hist) && ~isempty(opt.hist)
        Stat.hist.(name) = {histBins,histCount};
    end
    if isnumeric(opt.prctile) && ~isempty(opt.prctile)
        Stat.prctile.(name) = prctile(theta,opt.prctile,2);
    end
    if opt.bounds
        Stat.bounds.(name) = [This.lowerBounds(i),This.upperBounds(i)];
    end
    if ~isequal(opt.ksdensity,false)
        low = This.lowerBounds(i);
        high = This.upperBounds(i);
        [x,y] = poster.myksdensity(theta,low,high,opt.ksdensity);
        Stat.ksdensity.(name) = [x,y];
    end
    
    if opt.progress
        update(progress,i/nPar);
    elseif opt.esttime
        update(eta,i/nPar);
    end
    
end

% We subtract the mean from `Theta`. The original `Theta` is not available
% any longer after this point.
if opt.cov || opt.mdd
    Sgm = nan(nPar);
    doCov();
end

if opt.cov
    Stat.cov = Sgm;
end

if opt.mdd
    uuu = nan(1,N);
    doUuu();
    Stat.mdd = doMdd();
end

% Nested functions.

%**************************************************************************
    function doMean()
        if isFile
            for ii = 1 : nPar
                theta = nan(1,N);
                doGetTheta(ii);
                thetaMean(ii) = sum(theta) / N;
            end
        else
            thetaMean = sum(Theta,2) / N;
        end
    end % doMean().

%**************************************************************************
    function doCov()
        if isFile
            Sgm = zeros(nPar);
            for ii = 1 : master.SaveCount
                thistheta = mat{ii}.Theta;
                for jj = 1 : nPar
                    thistheta(jj,:) = thistheta(jj,:) - thetaMean(jj);
                end
                Sgm = Sgm + thistheta * thistheta.' / N;
            end
        else
            for ii = 1 : nPar
                Theta(ii,:) = Theta(ii,:) - thetaMean(ii);
            end
            Sgm = Theta * Theta.' / N;
        end
    end % doCov().

%**************************************************************************
    function d = doMdd()
        % doMdd  Modified harmonic mean estimator of minus the log marginal data
        % density; Geweke (1999).
        
        % Copyright (c) 2010-2013 IRIS Solutions Team & Troy Matheson.
        logdetsigma = log(det(Sgm));
        
        % Compute g(theta) := f(theta) / post(theta) for all thetas,
        % where f(theta) is given by (4.3.2) in Geweke (1999).
        if isFile
            LogPost = nan(1,N);
            doGetLogPost();
        end
        logg = -(nPar*log(2*pi) + logdetsigma + uuu)/2 - LogPost;
        
        % Normalise the values of the g function by its average so that the
        % later sums does not grow too high. We're adding `avglogg` back
        % again.
        avglogg = sum(logg) / N;
        logg = logg - avglogg;
        
        d = [];
        for pr = opt.mddgrid(:).'
            crit = chi2inv(pr,nPar);
            index = crit >= uuu;
            if any(index)
                tmp = sum(exp(-log(pr) + logg(index))) / N;
                d(end+1) = log(tmp) + avglogg; %#ok<AGROW>
            end
        end
        d = -mean(d);
    end % doMdd().

%**************************************************************************
    function doUuu()
        invSigma = inv(Sgm);
        if isFile
            pos = 0;
            for ii = 1 : master.SaveCount
                thisTheta = mat{ii}.Theta;
                for jj = 1 : nPar
                    thisTheta(jj,:) = thisTheta(jj,:) - thetaMean(jj);
                end
                for jj = 1 : size(thisTheta,2)
                    pos = pos + 1;
                    uuu(pos) = ...
                        thisTheta(:,jj).' * invSigma * thisTheta(:,jj); %#ok<MINV>
                end
            end
        else
            % `Theta` is already demeand at this point.
            for jj = 1 : N
                uuu(jj) = Theta(:,jj).' * invSigma * Theta(:,jj); %#ok<MINV>
            end
        end
    end % doUuu().

%**************************************************************************
    function doChkPosterFiles()
        master = load(inputfile);
        valid = isstruct(master) ...
            && isfield(master,'SaveCount') ...
            && isnumericscalar(master.SaveCount) ...
            && isfield(master,'Draw') ...
            && isnumericscalar(master.Draw) ...
            && isfield(master,'PList') ...
            && iscellstr(master.PList);
        valid = valid && isequal(This.paramList,master.PList);
        N = master.Draw;
        nPar = length(This.paramList);
        if valid
            nDraw = 0;
            for ii = 1 : master.SaveCount
                thisFile = sprintf('%s%g',inputfile,ii);
                mat{ii} = matfile(thisFile);
                thisWho = who('-file',thisFile);
                valid = valid ...
                    && length(thisWho) == 2 ...
                    && any(strcmp(thisWho,'Theta')) ...
                    && any(strcmp(thisWho,'LogPost'));
                [nPar,nTheta] = size(mat{ii},'Theta');
                [~,nLogPost] = size(mat{ii},'LogPost');
                valid = valid ...
                    && nTheta == nLogPost ...
                    && nPar == length(master.PList);
                nDraw = nDraw + nTheta;
            end
            valid = valid && nDraw == master.Draw;
        end
        if ~valid
            utils.error('poster', ...
                'The posterior simulation file ''%s'' is invalid.');
        end
    end % doChkPosterFiles().

%**************************************************************************
    function doGetTheta(i)
        count = 0;
        for ii = 1 : master.SaveCount
            [~,n] = size(mat{ii},'Theta');
            theta(1,count+(1:n)) = mat{ii}.Theta(i,:);
            count = count + n;
        end
    end % doGetTheta().

%**************************************************************************
    function doGetLogPost()
        count = 0;
        for ii = 1 : master.SaveCount
            [~,n] = size(mat{ii},'LogPost');
            LogPost(1,count+(1:n)) = mat{ii}.LogPost;
            count = count + n;
        end
    end % doGetLogPost().

%**************************************************************************
    function doOutpOpt()
        if ~isempty(opt.output)
            utils.warning('poster', ...
                ['This is an obsolete way of requesting output characteristics ',...
                'from stats(). See help for more information.']);
            output = opt.output;
            if ischar(output)
                output = regexp(output,'\w+','match');
            end            
            output = strrep(output,'prctile','prctile');
            list = {'chain','cov','mean','median','mode','mdd','std', ...
                'bounds','ksdensity'};
            for ii = 1 : length(list)
                opt.(list{ii}) = any(strcmpi(list{ii},output));
            end
            if any(strcmpi(output,'prctile'))
                if isempty(opt.prctile)
                    opt.prctile = [10,90];
                end
            else
                opt.prctile = [];
            end
            if any(strcmpi(output,'hpdi'))
                opt.hpdi = opt.hpdicover;
            else
                opt.hpdi = [];
            end
            if any(strcmpi(output,'hist'))
                opt.hist = opt.histbins;
            else
                opt.hist = [];
            end
        else
            if isequal(opt.prctile,true)
                opt.prctile = [10,90];
            end
            if isequal(opt.hpdi,true)
                opt.hpdi = 90;
            end
            if isequal(opt.hist,true)
                opt.hist = 50;
            end
        end
    end % doOutpOpt().

end
