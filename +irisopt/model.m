function Def = model()
% model  [Not a public function] Default options for model class functions.
%
% Backend IRIS function.
% No help provided.

% -IRIS Toolbox.
% -Copyright (c) 2007-2014 IRIS Solutions Team.

%--------------------------------------------------------------------------

solveValid = @(x) is.logicalscalar(x) ...
    || (iscell(x) && iscellstr(x(1:2:end)));

deviation_dtrends = { ...
    'deviation,deviations',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'dtrends,dtrend','auto',@(x) is.logicalscalar(x) || isequal(x,'auto'), ...
    };

precision = { ...
    'precision','double',@(x) is.anychari(x,{'double','single'}), ...
    };

applyfilter = {
    'applyto',Inf,@(x) isequal(x,':') || isequal(x,Inf) || iscellstr(x), ...
    'filter','',@ischar, ...
    };

swap = { ...
    'endogenise,endogenize',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'exogenise,exogenize',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    };

output = { ...
    'output','namedmat',@(x) ischar(x) && any(strcmpi(x,{'namedmat','numeric'})), ...
    };

sstate = { ...
    'sstate,sstateopt',false,@(x) islogical(x) ...
    || (iscell(x) && iscellstr(x(1:2:end))) ...
    || isa(x,'function_handle') ...
    || (iscell(x) && ~isempty(x) && isa(x{1},'function_handle')), ...
    };

mysstate = { ...
    'blocks,block',false,@(varargin)is.logicalscalar(varargin{:}), ...
    swap{:}, ...
    'fix',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'fixallbut',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'fixlevel',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'fixlevelallbut',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'fixgrowth',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'fixgrowthallbut',{},@(x) isempty(x) || iscellstr(x) || ischar(x), ...
    'growth',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'linear','auto',@(x) is.logicalscalar(x) ...
    || (ischar(x) && strcmpi(x,'auto')), ...
    'maxiter',1000,@(x) isnumeric(x) && length(x) == 1 && round(abs(x)) == x, ...
    'maxfunevals',1000,@(x) isnumeric(x) && length(x) == 1 && round(abs(x)) == x, ...
    'optimset',{},@(x) isempty(x) || (iscell(x) && iscellstr(x(1:2:end))), ...
    'naninit,init',1,@(x) is.numericscalar(x) && isfinite(x), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'resetinit',[],@(x) isempty(x) || (is.numericscalar(x) && isfinite(x)), ...
    'reuse',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'solver','lsqnonlin',@(x) ischar(x) || is.func(x), ...
    'tolx',1e-12,@(x) isnumeric(x) && length(x) == 1 && x > 0, ...
    'tolfun',1e-12,@(x) isnumeric(x) && length(x) == 1 && x > 0, ...
    'zeromultipliers',false,@(varargin)is.logicalscalar(varargin{:}), ...
    };


Def = struct();

Def.acf = {
    'acf',{},@(x) iscell(x) && iscellstr(x(1:2:end)), ...
    applyfilter{:}, ...
    'nfreq',256,@(varargin)is.numericscalar(varargin{:}), ...
    'contributions,contribution',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'order',0,@(varargin)is.numericscalar(varargin{:}), ...
    output{:}, ...
    'select',Inf,@(x) (isnumeric(x) && all(isinf(x))) || iscellstr(x) || ischar(x), ...
    }; %#ok<*CCAT>

Def.bn = { ...
    deviation_dtrends{:}, ...
    }; %#ok<CCAT1>

Def.chkmissing = { ...
    'error',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.chksstate = { ...
    'error',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'warning',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.mychksstate = { ...
    'eqtn,sstateeqtn','full',@(x) (ischar(x) && any(strcmpi(x,{'full','sstate'}))) || is.logicalscalar(x), ...
    'tolerance',getrealsmall(),@(varargin)is.numericscalar(varargin{:}), ...
    };

Def.diffloglik = {...
    'chksstate',true,@(x) is.logicalscalar(x) ...
    || (iscell(x) && iscellstr(x(1:2:end))), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'solve',true,solveValid, ...
    sstate{:}, ...
    };

% Combine model/estimate with estimateobj/myestimate.
estimateobj = irisopt.estimateobj();
Def.estimate = [ ...
    estimateobj.myestimate, { ...
    'chksstate',true,@(x) is.logicalscalar(x) ...
    || (iscell(x) && iscellstr(x(1:2:end))), ...
    'domain','time',@(x) any(strncmpi(x,{'t','f'},1)), ...
    'filter,filteropt',{},@(x) isempty(x) ...
    || (iscell(x) && iscellstr(x(1:2:end))), ...
    'nosolution','error',@(x) any(strcmpi(x,{'error','penalty'})), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'solve',true,solveValid, ...
    sstate{:}, ...
    'zero',false,@(varargin)is.logicalscalar(varargin{:}), ...
    }];

Def.fevd = {
    'select',Inf,@(x) isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    output{:}, ...
    };

Def.fmse = {
    'select',Inf,@(x) isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    output{:}, ...
    };

Def.ffrf = {
    'include',Inf,@(x) isempty(x) || isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    'exclude',{},@(x) isempty(x) || ischar(x) || iscellstr(x), ...
    'maxiter',[],@(x) isempty(x) || (is.numericscalar(x) && x >= 0), ...
    output{:}, ...
    'select',Inf,@(x) isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    'tolerance',[],@(x) isempty(x) || (is.numericscalar(x) && x > 0), ...
    };

Def.filter = { ...
    'data,output','smooth',@(x) ischar(x), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.fisher = { ...
    'chksgf',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'chksstate',true,@(x) is.logicalscalar(x) ...
    || (iscell(x) && iscellstr(x(1:2:end))), ...
    'deviation',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'epspower',1/3,@(varargin)is.numericscalar(varargin{:}), ...
    'exclude',{},@(x) ischar(x) || iscellstr(x), ...
    'percent',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'solve',true,solveValid,...
    sstate{:}, ...
    'tolerance',eps()^(2/3),@(varargin)is.numericscalar(varargin{:}), ...
    };

Def.forecast = {...
    'anticipate',true,@(varargin)is.logicalscalar(varargin{:}), ...
    deviation_dtrends{:}, ...
    'initcond','data',@(x) any(strcmpi(x,{'data','fixed'})) || isnumeric(x), ...
    'meanonly',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'std',[],@(x) isstruct(x) || isempty(x), ...
    'tolmse',getrealsmall('mse'),@(x) isnumeric(x) && length(x) == 1, ...
    };

Def.jforecast = {...
    'anticipate',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'currentonly',true,@(varargin)is.logicalscalar(varargin{:}), ...
    deviation_dtrends{:}, ...
    'initcond','data',@(x) any(strcmpi(x,{'data','fixed'})) || isnumeric(x), ...
    'meanonly',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'precision','double',@(x) ischar(x) && any(strcmpi(x,{'double','single'})), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'plan',[],@(x) isa(x,'plan') || isempty(x), ...
    'vary,std',[],@(x) isstruct(x) || isempty(x), ...
    };

Def.icrf = {...
    'delog',true,@(varargin)is.logicalscalar(varargin{:}),...
    'log',[],@(x) isempty(x) || is.logicalscalar(x), ...
    'size',[],@(x) isempty(x) || is.numericscalar(x), ...
    };

Def.ifrf = {...
    output{:}, ...
    'select',Inf,@(x) isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    };

Def.loglik = { ...
    'domain','time',@(x) any(strncmpi(x,{'t','f'},1)), ...
    'persist',false,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.fdlik = { ...
    'band',[2,Inf],@(x) isnumeric(x) && length(x) == 2, ...
    deviation_dtrends{:}, ...
    'exclude',[],@(x) isempty(x) || ischar(x) || iscellstr(x) || islogical(x), ...
    'objdecomp',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'outoflik',{},@(x) ischar(x) || iscellstr(x), ...
    'relative',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'zero',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.lognormal = { ...
    'fresh',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'mean',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'median',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'mode',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'prctile,pctile,pct',[5,95],@(x) isnumeric(x) && all(round(x(:)) > 0 & round(x(:)) < 100), ...
    'prefix','lognormal',@(x) ischar(x) && ~isempty(x), ...
    'std',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.kalman = { ...
    'ahead',1,@(x) is.numericscalar(x) && x > 0 && x == round(x), ...    
    'chkexact',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'chkfmse',false,@(varargin)is.logicalscalar(varargin{:}), ...
    deviation_dtrends{:}, ...
    'condition',[],@(x) isempty(x) || ischar(x) || iscellstr(x) || islogical(x), ...
    'fmsecondtol',eps(),@(x) is.numericscalar(x) && x > 0 && x < 1, ...
    'returncont,contributions',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'initcond,init','stochastic',@(x) ...
    isstruct(x) ...
    || (ischar(x) && any(strcmpi(x,{'stochastic','fixed','optimal'}))), ...
    'initmeanunit','optimal',@(x) ...
    isstruct(x) || (ischar(x) && any(strcmpi(x,{'optimal'}))), ...
    'lastsmooth',Inf,@(x) isempty(x) || is.numericscalar(x), ...
    'nonlinear,nonlinearise,nonlinearize',0, ...
    @(x) is.numericscalar(x) && x == round(x) && x >= 0, ...
    'outoflik',{},@(x) ischar(x) || iscellstr(x), ...
    'objdecomp',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'objfunc,objective','loglik',@(x) any(strcmpi(x,{'loglik','mloglik','-loglik','prederr'})), ...
    'objrange,objectivesample',Inf,@isnumeric, ...
    'pedindonly',false,@(varargin)is.logicalscalar(varargin{:}), ...
    precision{:}, ...
    'plan',[],@(x) isa(x,'plan') || isempty(x), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'relative',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'vary,std',[],@(x) isempty(x) || isstruct(x), ...
    'simulate',{},@(x) iscell(x) && iscellstr(x(1:2:end)), ...
    'symmetric',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'tolerance',eps()^(2/3),@isnumeric, ...
    'tolmse',0,@(x) (ischar(x) && strcmpi(x,'auto')) || is.numericscalar(x), ...
    'weighting',[],@isnumeric, ...
    'meanonly',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'returnstd',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'returnmse',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.model = {
    'addlead',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'declareparameters',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'multiple,allowmultiple',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'assign',[],@(x) isempty(x) || isstruct(x), ...
    'blazer',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'chksyntax',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'comment','',@ischar, ...
    'optimal','discretion', ...
    @(x) any(strcmpi(x,{'consistent','commitment','discretion'})), ...
    'epsilon',[],@(x) isempty(x) || (is.numericscalar(x) && x > 0 && x < 1), ...
    'removeleads,removelead',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'linear',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'multipliername','Mu_Eq%g',@(x) ischar(x) && ~isempty(strfind(x,'%g')), ...
    'precision','double',@(x) any(strcmp(x,{'double','single'})), ...
    'quadratic',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'saveas','',@ischar, ...
    'sstateonly',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'symbdiff,symbolicdiff',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'std',NaN,@(varargin)is.numericscalar(varargin{:}), ...
    'tolerance',[],@(x) isempty(x) || (is.numericscalar(x) && x >= 0), ...
    'baseyear,torigin',@config,@(x) isequal(x,@config) || isempty(x) || is.intscalar(x), ...
    };

Def.neighbourhood = { ...
    'plot',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'neighbourhood',[],@(x) isempty(x) || isstruct(x), ...
    };

Def.tcorule = { ...
    'beta',1,@(varargin)is.numericscalar(varargin{:}), ...
    'display',5000,@(varargin)is.numericscalar(varargin{:}), ...
    'ginverse',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'initexp',@eye,@(x) isnumeric(x) || is.func(x), ...
    'maxiter',50000,@(varargin)is.numericscalar(varargin{:}), ...
    'reset',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'tolexp',1e-10,@(varargin)is.numericscalar(varargin{:}), ...
    'tolrule',1e-10,@(varargin)is.numericscalar(varargin{:}), ...
    'tolvalue',1e-6,@(varargin)is.numericscalar(varargin{:}), ...
    'warning',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.regress = { ...
    'acf',{},@(x) iscell(x) && iscellstr(x(1:2:end)), ...
    output{:}, ...
    };
    
Def.resample = { ...
    deviation_dtrends{:}, ...
    'method','montecarlo',@(x) is.func(x) ...
    || (ischar(x) && any(strcmpi(x,{'montecarlo','bootstrap'}))), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'randominitcond,randomiseinitcond,randomizeinitcond,randomise,randomize',true,@(x) is.logicalscalar(x) || (is.numericscalar(x) && x >= 0), ...
    'svdonly',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'statevector','alpha',@(x) ischar(x) && any(strcmpi(x,{'alpha','x'})), ...
    'vary',[],@(x) isempty(x) || isstruct(x), ...
    'wild',false,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.shockplot = { ...
    'dbplot',{},@(x) iscell(x) && iscellstr(x(1:2:end)), ...
    'deviation',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'dtrends,dtrend','auto',@(x) is.logicalscalar(x) || isequal(x,'auto'), ...
    'simulate',{},@(x) iscell(x) && iscellstr(x(1:2:end)), ...
    'shocksize,size','std',@(x) (ischar(x) && strcmpi(x,'std')) || isnumeric(x), ...
    };

Def.simulate = { ...
    'anticipate',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'contributions,contribution',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'dboverlay,dbextend',false,@(x) is.logicalscalar(x) || isstruct(x), ...
    deviation_dtrends{:}, ...
    'fast',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'ignoreshocks,ignoreshock,ignoreresiduals,ignoreresidual', ...
    false,@(varargin)is.logicalscalar(varargin{:}), ...
    'plan',[],@(x) isa(x,'plan') || isempty(x), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'missing',NaN,@isnumeric, ...
    ... Options for non-linear simulations
    'nonlinearise,nonlinearize,nonlinear', ...
    0,@(x) isempty(x) || isnumeric(x), ...
    'addsstate',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'display', ...
    100,@(x) is.logicalscalar(x) || (is.numericscalar(x) && x >= 0 && x == round(x)), ...
    'error',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'fillout',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'lambda',1,@(x) is.numericscalar(x) && all(x > 0 & x <= 1), ...
    'reducelambda,lambdafactor', ...
    0.5,@(x) is.numericscalar(x) && x > 0 && x <= 1, ...
    'maxiter',100,@(varargin)is.numericscalar(varargin{:}), ...
    'tolerance',1e-5,@(varargin)is.numericscalar(varargin{:}), ...
    'upperbound',1.5,@(x) is.numericscalar(x) && all(x > 1), ...
    };

Def.solve = { ...
    'expand,forward',0,@(x) isnumeric(x) && length(x) == 1, ...
    'fast',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'linear','auto',@(x) is.logicalscalar(x) ...
    || (ischar(x) && strcmpi(x,'auto')), ...
    'error',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'refresh',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'select',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'eqtn,equations','all',@(x) ischar(x) ...
    && any(strcmpi(x,{'all','measurement','transition'})), ...
    'symbolic',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'warning',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.sourcedb = { ...
    'ndraw',1,@(x) is.numericscalar(x) && x >= 0 && x == round(x), ...
    'ncol',1,@(x) is.numericscalar(x) && x >= 0 && x == round(x), ...
    deviation_dtrends{:}, ...
    'randomshocks,randomshock',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'residuals,residual',[],@(x) isempty(x) || is.func(x), ...
    };

Def.srf = {...
    'log',[],@(x) isempty(x) || is.logicalscalar(x), ...
    'delog',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'select',Inf,@(x) (isnumeric(x) && length(x) == 1 && isinf(x)) || iscellstr(x) || ischar(x), ...
    'size','std',@(x) (ischar(x) && strcmpi(x,'std')) || is.numericscalar(x), ...
    };

Def.sspace = { ...
    'triangular',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'removeinactive',false,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.sstate = { ...
    'linear','auto',@(x) isequal(x,'auto') ...
    || isequal(x,true) || isequal(x,false), ...
    'solve',false,solveValid, ...
    };

Def.mysstateverbose = { ...
    mysstate{:}, ...
    'display','iter',@(x) isempty(x) || islogical(x) || is.anychari(x,{'iter','final','off','notify','none'}), ...
    'warning',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.mysstatesilent = { ...
    mysstate{:}, ...
    'display','off',@(x) isempty(x) || islogical(x) || is.anychari(x,{'iter','final','off','notify','none'}), ...
    'warning',false,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.sstatefile = { ...
    swap{:}, ...
    'growthnames,growthname','d?',@ischar, ...
    'time',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.system = { ...
    'eqtn,equations','all',@(x) ischar(x), ...
    'linear','auto',@(x) is.logicalscalar(x) ...
    || (ischar(x) && strcmpi(x,'auto')), ...
    'select',true,@(varargin)is.logicalscalar(varargin{:}), ...
    'sparse',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'symbolic',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.VAR = { ...
    'acf',{},@(x) iscell(x) && iscellstr(x(1:2:end)), ...
    'order',1,@(varargin)is.numericscalar(varargin{:}), ...
    'constant,const',true,@(varargin)is.logicalscalar(varargin{:}), ...
    };

Def.vma = {
    'select',Inf,@(x) isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    output{:}, ...
    };

Def.xsf = {
    applyfilter{:}, ...
    output{:}, ...
    'progress',false,@(varargin)is.logicalscalar(varargin{:}), ...
    'select',Inf,@(x) isequal(x,Inf) || ischar(x) || iscellstr(x), ...
    };

end